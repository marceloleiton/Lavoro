{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ViewPager = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactNative = _interopRequireWildcard(require(\"react-native\"));\n\nvar _utils = require(\"./utils\");\n\nvar _ViewPagerNative = require(\"./ViewPagerNative\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ViewPager = function (_React$Component) {\n  (0, _inherits2.default)(ViewPager, _React$Component);\n\n  var _super = _createSuper(ViewPager);\n\n  function ViewPager() {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, ViewPager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"isScrolling\", false);\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"viewPager\", _react.default.createRef());\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"getInnerViewNode\", function () {\n      return _this.viewPager.current.getInnerViewNode();\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"_onPageScroll\", function (e) {\n      if (_this.props.onPageScroll) {\n        _this.props.onPageScroll(e);\n      }\n\n      if (_reactNative.Platform.OS === 'android') {\n        if (_this.props.keyboardDismissMode === 'on-drag') {\n          _reactNative.Keyboard.dismiss();\n        }\n      }\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"_onPageScrollStateChanged\", function (e) {\n      if (_this.props.onPageScrollStateChanged) {\n        _this.props.onPageScrollStateChanged(e);\n      }\n\n      _this.isScrolling = e.nativeEvent.pageScrollState === 'dragging';\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"_onPageSelected\", function (e) {\n      if (_this.props.onPageSelected) {\n        _this.props.onPageSelected(e);\n      }\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"setPage\", function (selectedPage) {\n      _reactNative.UIManager.dispatchViewManagerCommand(_reactNative.default.findNodeHandle((0, _assertThisInitialized2.default)(_this)), (0, _ViewPagerNative.getViewManagerConfig)().Commands.setPage, [selectedPage]);\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"setPageWithoutAnimation\", function (selectedPage) {\n      _reactNative.UIManager.dispatchViewManagerCommand(_reactNative.default.findNodeHandle((0, _assertThisInitialized2.default)(_this)), (0, _ViewPagerNative.getViewManagerConfig)().Commands.setPageWithoutAnimation, [selectedPage]);\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"setScrollEnabled\", function (scrollEnabled) {\n      _reactNative.UIManager.dispatchViewManagerCommand(_reactNative.default.findNodeHandle((0, _assertThisInitialized2.default)(_this)), (0, _ViewPagerNative.getViewManagerConfig)().Commands.setScrollEnabled, [scrollEnabled]);\n    });\n\n    _defineProperty((0, _assertThisInitialized2.default)(_this), \"_onMoveShouldSetResponderCapture\", function () {\n      return _this.isScrolling;\n    });\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(ViewPager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (_reactNative.Platform.OS === 'android') {\n        if (this.props.initialPage != null) {\n          this.setPageWithoutAnimation(this.props.initialPage);\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react.default.createElement(_ViewPagerNative.ViewpagerViewManager, _extends({}, this.props, {\n        ref: this.viewPager,\n        style: this.props.style,\n        onPageScroll: this._onPageScroll,\n        onPageScrollStateChanged: this._onPageScrollStateChanged,\n        onPageSelected: this._onPageSelected,\n        onMoveShouldSetResponderCapture: this._onMoveShouldSetResponderCapture,\n        children: (0, _utils.childrenWithOverriddenStyle)(this.props.children)\n      }));\n    }\n  }]);\n  return ViewPager;\n}(_react.default.Component);\n\nexports.ViewPager = ViewPager;","map":{"version":3,"sources":["ViewPager.tsx"],"names":["React","componentDidMount","Platform","e","Keyboard","selectedPage","UIManager","ReactNative","getViewManagerConfig","scrollEnabled","render","viewPager","childrenWithOverriddenStyle"],"mappings":"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","sourcesContent":["import React, { ReactElement } from 'react';\nimport { Platform, UIManager, Keyboard } from 'react-native';\nimport ReactNative from 'react-native';\nimport type {\n  ViewPagerOnPageScrollEvent,\n  ViewPagerOnPageSelectedEvent,\n  PageScrollStateChangedNativeEvent,\n  ViewPagerProps,\n} from './types';\n\nimport { childrenWithOverriddenStyle } from './utils';\nimport { getViewManagerConfig, ViewpagerViewManager } from './ViewPagerNative';\n\n/**\n * Container that allows to flip left and right between child views. Each\n * child view of the `ViewPager` will be treated as a separate page\n * and will be stretched to fill the `ViewPager`.\n *\n * It is important all children are `<View>`s and not composite components.\n * You can set style properties like `padding` or `backgroundColor` for each\n * child. It is also important that each child have a `key` prop.\n *\n * Example:\n *\n * ```\n * render: function() {\n *   return (\n *     <ViewPager\n *       style={styles.viewPager}\n *       initialPage={0}>\n *       <View style={styles.pageStyle} key=\"1\">\n *         <Text>First page</Text>\n *       </View>\n *       <View style={styles.pageStyle} key=\"2\">\n *         <Text>Second page</Text>\n *       </View>\n *     </ViewPager>\n *   );\n * }\n *\n * ...\n *\n * var styles = {\n *   ...\n *   viewPager: {\n *     flex: 1\n *   },\n *   pageStyle: {\n *     alignItems: 'center',\n *     padding: 20,\n *   }\n * }\n * ```\n */\n\nexport class ViewPager extends React.Component<ViewPagerProps> {\n  private isScrolling = false;\n  private viewPager = React.createRef<typeof ViewpagerViewManager>();\n\n  componentDidMount() {\n    // On iOS we do it directly on the native side\n    if (Platform.OS === 'android') {\n      if (this.props.initialPage != null) {\n        this.setPageWithoutAnimation(this.props.initialPage);\n      }\n    }\n  }\n\n  public getInnerViewNode = (): ReactElement => {\n    return this.viewPager.current!.getInnerViewNode();\n  };\n\n  private _onPageScroll = (e: ViewPagerOnPageScrollEvent) => {\n    if (this.props.onPageScroll) {\n      this.props.onPageScroll(e);\n    }\n    // Not implemented on iOS yet\n    if (Platform.OS === 'android') {\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private _onPageScrollStateChanged = (\n    e: PageScrollStateChangedNativeEvent\n  ) => {\n    if (this.props.onPageScrollStateChanged) {\n      this.props.onPageScrollStateChanged(e);\n    }\n    this.isScrolling = e.nativeEvent.pageScrollState === 'dragging';\n  };\n\n  private _onPageSelected = (e: ViewPagerOnPageSelectedEvent) => {\n    if (this.props.onPageSelected) {\n      this.props.onPageSelected(e);\n    }\n  };\n\n  /**\n   * A helper function to scroll to a specific page in the ViewPager.\n   * The transition between pages will be animated.\n   */\n  public setPage = (selectedPage: number) => {\n    UIManager.dispatchViewManagerCommand(\n      ReactNative.findNodeHandle(this),\n      getViewManagerConfig().Commands.setPage,\n      [selectedPage]\n    );\n  };\n\n  /**\n   * A helper function to scroll to a specific page in the ViewPager.\n   * The transition between pages will *not* be animated.\n   */\n  public setPageWithoutAnimation = (selectedPage: number) => {\n    UIManager.dispatchViewManagerCommand(\n      ReactNative.findNodeHandle(this),\n      getViewManagerConfig().Commands.setPageWithoutAnimation,\n      [selectedPage]\n    );\n  };\n\n  /**\n   * A helper function to enable/disable scroll imperatively\n   * The recommended way is using the scrollEnabled prop, however, there might be a case where a\n   * imperative solution is more useful (e.g. for not blocking an animation)\n   */\n  public setScrollEnabled = (scrollEnabled: boolean) => {\n    UIManager.dispatchViewManagerCommand(\n      ReactNative.findNodeHandle(this),\n      getViewManagerConfig().Commands.setScrollEnabled,\n      [scrollEnabled]\n    );\n  };\n\n  private _onMoveShouldSetResponderCapture = () => {\n    return this.isScrolling;\n  };\n\n  render() {\n    return (\n      <ViewpagerViewManager\n        {...this.props}\n        ref={this.viewPager as any /** TODO: Fix ref type */}\n        style={this.props.style}\n        onPageScroll={this._onPageScroll}\n        onPageScrollStateChanged={this._onPageScrollStateChanged}\n        onPageSelected={this._onPageSelected}\n        onMoveShouldSetResponderCapture={this._onMoveShouldSetResponderCapture}\n        children={childrenWithOverriddenStyle(this.props.children)}\n      />\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}